---
title: JDK11中的新特性——HTTP Client
date: 2018-10-09 21:23:20
permalink: http-client-in-jdk11
updated: '2018-03-31 20:23:40'
tags: 基础组件及平台
categories: 技术
---
北京时间 9 月 26 日，Oracle 官方宣布 Java 11 正式发布

# JDK11中的17个新特性
![JDK11中的17个新特性](http://www.yesdata.net/tigercat/jdk11-new-features.png)

# JDK11中引入HTTP Client的动机
既有的HttpURLConnection存在许多问题
* 其基类URLConnection当初是设计为支持多协议，但其中大多已经成为非主流（ftp, gopher…）
* API的设计早于HTTP/1.1，过度抽象
* 难以使用，存在许多没有文档化的行为
* 它只支持阻塞模式（每个请求/响应占用一个线程）

# HTTP Client发展史
![HTTP Client发展史](http://www.yesdata.net/tigercat/jdk11-httpclient-map.png)

# 在JDK11 HTTP Client出现之前

在此之前，可以使用以下工具作为Http客户端
* JDK HttpURLConnection
* Apache HttpClient
* Okhttp
* Spring Rest Template
* Spring Cloud Feign
* 将Jetty用作客户端
* 使用Netty库。还

# 初探JDK HTTP Client
我们来看一段HTTP Client的常规用法的样例 ——
执行GET请求，然后输出响应体（Response Body）。
```
HttpClient client = HttpClient.newHttpClient();
HttpRequest request = HttpRequest.newBuilder()
      .uri(URI.create("http://openjdk.java.net/"))
      .build();
client.sendAsync(request, asString())
      .thenApply(HttpResponse::body)
      .thenAccept(System.out::println)
      .join();
```

# 第一步：创建HttpClient
一般使用JDK 11中的HttpClient的第一步是创建HttpClient对象并进行配置。
* 指定协议（http/1.1或者http/2）
* 转发（redirect）
* 代理（proxy）
* 认证（authenticator）
```
HttpClient client = HttpClient.newBuilder()
      .version(Version.HTTP_2)
      .followRedirects(Redirect.SAME_PROTOCOL)
      .proxy(ProxySelector.of(new InetSocketAddress("www-proxy.com", 8080)))
      .authenticator(Authenticator.getDefault())
      .build();
```

# 第二步：创建HttpRequest
从HttpRequest的builder组建request
* 请求URI
* 请求method（GET, PUT, POST）
* 请求体（request body）
* Timeout
* 请求头（request header）
```
HttpRequest request = HttpRequest.newBuilder()
      .uri(URI.create("http://openjdk.java.net/"))
      .timeout(Duration.ofMinutes(1))
      .header("Content-Type", "application/json")
      .POST(BodyPublisher.fromFile(Paths.get("file.json")))
      .build()
```

# 第三步：send
* http client可以用来发送多个http request
* 请求可以被以同步或异步方式发送

## 第三步：1. 同步发送
同步发送API阻塞直到HttpResponse返回

```
HttpResponse<String> response =
      client.send(request, BodyHandler.asString());
System.out.println(response.statusCode());
System.out.println(response.body());
```

## 第三步：2. 异步发送
* 异步发送API立即返回一个CompletableFuture
* 当它完成的时候会获得一个HttpResponse
```
client.sendAsync(request, BodyHandler.asString())
      .thenApply(response -> { System.out.println(response.statusCode());
                               return response; } )
      .thenApply(HttpResponse::body)
      .thenAccept(System.out::println);
```
*※CompletableFuture是在java8中加入的，支持组合式异步编程*

