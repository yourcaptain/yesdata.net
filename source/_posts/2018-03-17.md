---
date: 2018-03-17 20:28:29
title: 分布式系统开发工具包 —— 基于Kryo的Java对象序列化
permalink: kyro
updated: '2018-03-17 22:43:31'
tags: 基础组件及平台
categories: 技术
---

Kryo是用于Java语言的一个快速和高效的对象图序列化框架。Kryo项目的目的是快速、高效、方便地使用API。当需要持久化对象的时候，不论是持久化到文件、数据库还是网络，都可以使用Kryo。

目前Kryo已经到了4.0.1版本以上了。本文的介绍适用于V2.0+以上版本。

# 安装Kryo

一般适用maven来Kryo包。

使用官方版的Kryo的话可以引用下述配置代码
```
<dependency>
    <groupId>com.esotericsoftware</groupId>
        <artifactId>kryo</artifactId>
    <version>4.0.1</version>
</dependency>
```

<!--more-->

如果你已经在你的classpath下有了不同版本的asm了的话，上述依赖可能会碰到问题。这时你可以使用kyro-shaded jar包，它自身包含了它所需版本的asm，并且是位于在不同包里的。
```
<dependency>
    <groupId>com.esotericsoftware</groupId>
        <artifactId>kryo-shaded</artifactId>
    <version>4.0.1</version>
</dependency>
```

如果你想试用最新的特性

```
<repository>
   <id>sonatype-snapshots</id>
   <name>sonatype snapshots repo</name>
   <url>https://oss.sonatype.org/content/repositories/snapshots</url>
</repository>
    
<dependency>
   <groupId>com.esotericsoftware</groupId>
       <artifactId>kryo</artifactId>
   <version>4.0.1-SNAPSHOT</version>
</dependency>
```

# 开始使用Kryo库

```
import com.esotericsoftware.kryo.Kryo;
import com.esotericsoftware.kryo.io.Output;
import com.esotericsoftware.kryo.io.Input;
// ...
Kryo kryo = new Kryo();
// ...
Output output = new Output(new FileOutputStream("file.bin"));
SomeClass someObject = ...
kryo.writeObject(output, someObject);
output.close();
// ...
Input input = new Input(new FileInputStream("file.bin"));
SomeClass someObject = kryo.readObject(input, SomeClass.class);
input.close();
```

Kryo类编排序列化，Output和Input类处理缓存字节和刷新到流中。


# IO
Output类是一个OutputStream，它将数据写入字节数组缓冲。如果需要一个字节数组的话，这个缓冲可以被获得并直接使用。如果这个Output被赋予一个OutputStream的话，当缓冲满了的话，它会flush字节到流里。Output有许多方法用于有效地写入基本类型和String到字节里。它提供了类似于DataOutputStream, BufferedOutputStream, FilterOutputStream, and ByteArrayOutputStream的功能。

因为Output作了缓冲，所以在写入一个OutputStream时，务必在写入结束时调用flush()或者close()方法，以便缓冲着的字节能够被写入底层流。


# Serializers
Kryo是一个序列化框架。它不会强迫一种模式或者要求写入或读出什么样的数据，这都留给Serializer本身去做。默认提供的Serializers可以以多种方式读写。如果这无法满足特定的需求，它们可以被部分替换或整体替换。默认提供的serializers可以读写多种对象，但，写一个新的serializer也很容易。Serializer抽象类提供了方法去转换对象到字节或字节到对象。

```
public class ColorSerializer extends Serializer<Color> {
   	public void write (Kryo kryo, Output output, Color object) {
   		output.writeInt(object.getRGB());
   	}
   
   	public Color read (Kryo kryo, Input input, Class<Color> type) {
   		return new Color(input.readInt(), true);
	}
}
```

Serializer有2个方法可以被实现。write()方法将对象写为字节；read()创建一个对象的新实例，并且从input读取内容来填充它。

Kryo实例可以被用于读写嵌入对象。如果Kryo在read()中被用于读一个嵌入对象，那么：
- 如果嵌入对象可能引用父对象的话，kryo.reference()必须被随父对象一起调用
- 如果嵌入对象不会引用父对象、Kryo没有被嵌入对象使用以及引用没有被使用的话，kryo.reference()可以不被随父对象一起调用
如果嵌入对象可以使用相同的serializer的话，那么serializer必须是可重入（reentrant）的。

代码不可以直接使用Serializers，应该使用Kryo的read和write方法，这使得Kryo能够编排序列化、处理诸如references和null objects这种特性。

默认地、serializers没必要处理null object。Kryo框架会根据需要写入一个byte代表null还是非null。如果serializers想要更加高效或想自己处理null，它可以调用```Serializer#setAcceptsNull(true)```。当已知一个类型的所有实例都绝不会为null时，这也可以被用来避免写入代表null的字节。

# Registration
当Kryo写出一个对象的实例时，首先它可能需要写出一些东西来代表对象的class。默认地，先写一个完全限定的class name，然后是实例对应的字节。写class name有点儿不太高效，所以可以在处理之前先注册这个类。
```
Kryo kryo = new Kryo();
kryo.register(SomeClass.class);
// ...
Output output = ...
SomeClass someObject = ...
kryo.writeObject(output, someObject);
```
这儿SomeClass被注册到Kryo中，class name会被关联到一个整数ID。当Kryo写出一个SomeClass的实例的时候，它将写出这个整数ID。这可比写出class name高效地多，但它需要提前知晓这个将被序列化的类。上面展示的register方法分配下一个、最小的整数ID，它意味着类的注册顺序是很重要的。ID也可以被显示指定，使得顺序无关紧要。
```
Kryo kryo = new Kryo();
kryo.register(SomeClass.class, 10);
kryo.register(AnotherClass.class, 11);
kryo.register(YetAnotherClass.class, 12);
```
小的正整数是最高效的。负数不能被有效地序列化。-1和-2是保留的。

注册与不注册可以混用。所有基本类型、包装过的基本类型、String和void默认被注册为ID从0-9，所以注意不要把其他的注册到这个范围内了，以防覆盖了它们。

Kryo#setRegistrationRequired设为true，以便在发生未注册类时抛出异常。这阻止应用程序偶然地使用了class name字符串。

如果使用非注册类，那么尽量使用短的包名。



参考连接：

- [Kryo官网](https://github.com/EsotericSoftware/kryo)
- [用于网络的Kryo](https://github.com/EsotericSoftware/kryonet)
- [Kryo为什么比Hessian快](http://blog.csdn.net/sdujava2011/article/details/78199562)